---
title: "How to build shiny.trucks not shiny.cars!"
output: 
  html_document:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Why is this about trucks?

Last month the [R/Pharma](https://www.rinpharma.com) conference took place at the Harvard Campus in Boston. I presented our development project called bioWARP, which is a large [shiny](https://shiny.rstudio.com/) application of containing more than 500.000 lines of code. And I noticed, actually nobody ever came to the idea to write such a [shiny](https://shiny.rstudio.com/) application. And I asked myself, why? A major reason is, people do not need to do that! I now would like to explain why we went our way and did it. 

<div style="width:45%;float:left;margin-right:5%" align="justify">
Imagine our large [shiny](https://shiny.rstudio.com/) app as a truck, it's nearly a monster truck, but let's leave it a truck. It's a truck because our app has more than 500 interaction item. Measuring these as horse power (*HP*) it's a kind of regular truck. [Shiny](https://shiny.rstudio.com/) apps I see in my daily work have about 50 or even less interaction items, so it these be seen as a car. With less then 50, it's a rather small car like a mini cooper. So why did my customers require a truck?

Images by [Paul V](https://flic.kr/p/B4TwtZ) and [DaveR](https://flic.kr/p/q33yzD)
</div>
<div style="width:50%;float:left">
<a data-flickr-embed="true"  href="https://www.flickr.com/photos/85090026@N06/23016489623/in/photolist-B4TwtZ-9AAG2n-ATVCE2-8H7BXs-bWEepB-b5oGq6-9ScLZx-nsQVXP-SwRfJn-p4pBSb-s8qk1A-RdvAzc-UTegWT-V5ik7W-nFDVyu-U4hhS5-S1YzQ4-TNJKtE-VMa34Q-dbBA7T-dxY87H-AUKEtM-BSURfW-R8PE1f-TxSqCy-Rn42kf-UWcGq3-ni1aoM-b5tFPc-cHPh5h-boLdCo-dm5ESK-9RCSui-aWp9Z8-8C8Ng3-9A1yQq-azvuBD-SsHkof-Tvu42W-RnbZWN-qHYHjN-of5Sks-BhCWbB-pqEKus-8CFqHD-aSwrqB-gcnXM8-dD4kxS-eNo35G-RuQVQa" title="Peterbilt Truck"><img src="https://farm1.staticflickr.com/743/23016489623_736b8a0fe9_k.jpg" width="47%" alt="Peterbilt Truck" style="float:left"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script>

<a data-flickr-embed="true"  href="https://www.flickr.com/photos/paulsimpsonphotography/13976701169/in/photolist-ni5fjn-hEgG2w-dTbDzB-abjfn3-3taEfy-dLxzEr-5yi6v6-jsLLQY-83tFh7-n2RGZ-q33yzD-ajnH6q-ndAoYs-ejZRJ2-FWSHe-dT9v4V-8JBRm6-8JBMHn-ag2k7S-ggMQTe-8JBRUa-nuN77T-dVSEWm-poHbs9-ERMU7x-51keup-e87ZL9-6FMLjc-sbUX5C-eahQCz-cdeN9f-5YJau2-nGsU7-E2HYa-9YM6rR-5RfA6G-6FMQFi-5qSaux-9tMCaH-aTH7rc-5bk6Eq-6ndgG5-2Vj84C-h1SGnS-5gsVwN-m7CnAF-6UeYKd-32NNds-fzmfft-8kMdQ2" title="Red Mini Cooper"><img src="https://farm3.staticflickr.com/2902/13976701169_cb0c28b2b3_z.jpg" width="49%" style="float:left" alt="Red Mini Cooper"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script>

</div>
<div style="clear:both"></div>

## Why do we need a truck?

Building software often starts with checking the user requirements. So when we started the development of our statistical web application, we did that, too. Asking a lot of people inside our deparment we noticed, that the list is huge:

* Pretty Design
* Interactive elements
* Mathematical correctness of all results
* Session logging
* Ability to restore sessions
* PDF reports of all results
* Allow users to require **special** application
* Harmonize it with other applications used
* **Everything** has to be tested

Additionally it was required to write the whole application in **R** as all our mathematical packages are written in **R**. So we decided for doing it all with [shiny](https://shiny.rstudio.com/).

## How did we build the truck?

### Modularity

Inside our department we were running some large scale desktop applications already. When it came to testing we always noticed, that testing takes forever. If each of the same software gathers data, calculates statistics, provides plot outputs and renders PDF reports, this truck is huge and you can just test it by driving it a thousand kilometers and see if it still works. The idea we came up with was building our truck out of lego brick. Each lego brick can be tested if it is strong enough. If a lego wheel runs, the truck will run. The wheel holder part is universal and if we change the size of the wheels, we can still run the truck. What this is called, is modularity. For this there exist different solutions which can be combined.

1) Shiny Modules
2) Object orientation
3) packaging of modules

As Shiny modules were not existing when we started, we chose option 2 and 3. As an example I'll compare two cars here. One modular by object orientation, one as a simple shiny application. The image below shall illustrate, that the renderPlot function in a standard shiny App has to account for one output element. In the first application, the Plot Element can be exchanged easily. Additionally it is 

![](./apps.png)

```{r, echo=TRUE,eval=F}
library(methods)
library(rlang)


setGeneric("plotElement",where = parent.frame(),def = function(object){standardGeneric("plotElement")})
setGeneric("shinyElement",where = parent.frame(),def = function(object){standardGeneric("shinyElement")})

setClass("AnyPlot", representation(plot_element = "call"))
setClass("HistPlot", representation(color="character",obs="numeric"), contains = "AnyPlot")

AnyPlot <- function(plot_element=expr(plot(1,1))){
  new("AnyPlot",
      plot_element = plot_element
  )
}

HistPlot <- function(color="darkgrey",obs=100){
  new("HistPlot",
      plot_element = expr(hist(rnorm(!!obs), col = !!color, border = 'white')),
      color = color,
      obs = obs
      )
}

#' Method to plot a Plot element
setMethod("plotElement",signature = "AnyPlot",definition = function(object){
  eval(object@plot_element)
})
#' Method to render a Plot Element
setMethod("shinyElement",signature = "AnyPlot",definition = function(object){
  renderPlot(plotElement(object))
})



server <- function(input, output, session) {
  
  # Create a reactive to create the Report object
  report_obj <- reactive(HistPlot(obs=input$obs))
  
  # Check for change of the slider to change the plots
  observeEvent(input$obs,{
    output$renderedPDF <- renderText("")
    output$renderPlot <-  shinyElement(  report_obj() )
  } )
  
}

# Simple shiny App containing the standard histogram + PDF render and Download button
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      sliderInput(
        "obs",
        "Number of observations:", min = 10, max = 500, value = 100)
    ),
    mainPanel(
      uiOutput("renderPlot")
    )
  )
)
shinyApp(ui = ui, server = server)
```
</div><div style="float:left;width:50%">
```{r, echo=TRUE,eval=F}










































server <- function(input, output) {
  # Output Gray Histogram
  output$distPlot <- renderPlot({
    hist(rnorm(input$obs), col = 'darkgray', border = 'white')
  })

}






# Simple shiny App containing the standard histogram + PDF render and Download button
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      sliderInput(
            "obs",
            "Number of observations:", min = 10, max = 500, value = 100)
    ),
    mainPanel(
      plotOutput("distPlot")
    )
  )
)
shinyApp(ui = ui, server = server)
```
</div>
<div stlye="clear:both"></div>


<a data-flickr-embed="true"  href="https://www.flickr.com/photos/157267479@N02/27368344058/in/photostream/" title="truck peterbilt"><img src="https://farm1.staticflickr.com/807/27368344058_4d23c92951_o.png" width="100%" alt="truck peterbilt"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script>

[Image by Barney Sharman](https://www.flickr.com/photos/157267479@N02/27368344058/in/photostream/)
